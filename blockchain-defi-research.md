# DeFi åè®®æ·±åº¦ç ”ç©¶

> **ç›®æ ‡**: æ·±å…¥ç ”ç©¶å»ä¸­å¿ƒåŒ–é‡‘èï¼ˆDeFiï¼‰åè®®çš„åŸç†ã€æœºåˆ¶ã€å•†ä¸šä»·å€¼å’ŒæŠ€æœ¯å®ç°

---

## ğŸ“‹ DeFi æ ¸å¿ƒæ¦‚å¿µ

### ä»€ä¹ˆæ˜¯ DeFiï¼Ÿ

**DeFi (Decentralized Finance)** - åŸºäºåŒºå—é“¾çš„é‡‘èæœåŠ¡ï¼Œæ— éœ€ä¸­å¿ƒåŒ–ä¸­ä»‹ï¼ˆé“¶è¡Œã€äº¤æ˜“æ‰€ç­‰ï¼‰ã€‚

```
ä¼ ç»Ÿé‡‘èï¼š
ç”¨æˆ· â†’ é“¶è¡Œ â†’ é“¶è¡Œ â†’ é“¶è¡Œ â†’ ç”¨æˆ·
      â†‘ ä¿¡ä»»ä¸­å¿ƒåŒ–æœºæ„
      â†‘ æ‰‹ç»­è´¹é«˜
      â†‘ é€Ÿåº¦æ…¢

DeFiï¼š
ç”¨æˆ· â†’ æ™ºèƒ½åˆçº¦ â†’ æ™ºèƒ½åˆçº¦ â†’ ç”¨æˆ·
      â†‘ æ— éœ€ä¿¡ä»»æœºæ„ï¼ˆCode is Lawï¼‰
      â†‘ æ‰‹ç»­è´¹ä½
      â†‘ é€Ÿåº¦å¿«
```

---

## ğŸ’° DeFi èµ›é“

### 1. å»ä¸­å¿ƒåŒ–äº¤æ˜“æ‰€ (DEX) â­â­â­â­â­â­

**å¸‚åœºè§„æ¨¡**: $100+ äº¿ç¾å…ƒ / å¢é•¿ç‡ 40%/å¹´

**ä»£è¡¨é¡¹ç›®**:
- Uniswap (TVL: $50äº¿+)
- PancakeSwap (TVL: $20äº¿+)
- Curve (TVL: $30äº¿+)

**æ”¶å…¥æ¥æº**:
- äº¤æ˜“æ‰‹ç»­è´¹ï¼ˆ0.05% - 0.3%ï¼‰
- ä»£å¸å‡å€¼ï¼ˆUNIã€CAKEï¼‰
- æµåŠ¨æ€§æŒ–çŸ¿å¥–åŠ±

**æ ¸å¿ƒæœºåˆ¶**: AMM (è‡ªåŠ¨åšå¸‚å•†)

---

### 2. å€Ÿè´·åè®® â­â­â­â­â­

**å¸‚åœºè§„æ¨¡**: $60+ äº¿ç¾å…ƒ / å¢é•¿ç‡ 35%/å¹´

**ä»£è¡¨é¡¹ç›®**:
- Aave (TVL: $80äº¿+)
- Compound (TVL: $20äº¿+)
- Lido (TVL: $30äº¿+)

**æ”¶å…¥æ¥æº**:
- å€Ÿæ¬¾åˆ©æ¯æ”¶å…¥ï¼ˆå€Ÿæ¬¾åˆ©ç‡ï¼‰
- å‚¨è“„åˆ©æ¯æ”¶å…¥ï¼ˆå­˜æ¬¾åˆ©ç‡ï¼‰
- æ¸…ç®—æƒ©ç½šæ”¶å…¥

**æ ¸å¿ƒæœºåˆ¶**: èµ„é‡‘æ± ã€æ¸…ç®—ã€åˆ©ç‡æ›²çº¿

---

### 3. ç¨³å®šå¸ â­â­â­â­â­

**å¸‚åœºè§„æ¨¡**: $140+ äº¿ç¾å…ƒ / å¢é•¿ç‡ 25%/å¹´

**ä»£è¡¨é¡¹ç›®**:
- USDT (å¸‚å€¼: $100äº¿+)
- USDC (å¸‚å€¼: $30äº¿+)
- DAI (å¸‚å€¼: $5äº¿+)

**æ”¶å…¥æ¥æº**:
- é“¸é€ æ‰‹ç»­è´¹ï¼ˆ0.1%ï¼‰
- ç¨³å®šè´¹ï¼ˆç»´æŒä»·æ ¼ç¨³å®šï¼‰
- èµ„é‡‘æ”¶ç›Šï¼ˆæŠ•èµ„å›½å€ºï¼‰

**æ ¸å¿ƒæœºåˆ¶**: ç®—æ³•ç¨³å®šï¼ˆè¶…é¢æŠµæŠ¼ã€Rebaseï¼‰ã€æ³•å¸æŠµæŠ¼

---

### 4. è·¨é“¾æ¡¥ â­â­â­â­

**å¸‚åœºè§„æ¨¡**: $20+ äº¿ç¾å…ƒ / å¢é•¿ç‡ 50%/å¹´

**ä»£è¡¨é¡¹ç›®**:
- Polygon Bridge (TVL: $5äº¿+)
- Multichain (TVL: $3äº¿+)
- Hop Protocol (TVL: $1äº¿+)

**æ”¶å…¥æ¥æº**:
- è·¨é“¾æ‰‹ç»­è´¹ï¼ˆ0.1% - 0.5%ï¼‰
- ä»£å¸å‡å€¼ï¼ˆMATICã€ANYï¼‰

**æ ¸å¿ƒæœºåˆ¶**: é”ä»“ã€è·¨é“¾æ¶ˆæ¯ä¼ é€’ã€ä¸­ç»§éªŒè¯

---

## ğŸ”„ AMM (è‡ªåŠ¨åšå¸‚å•†) æ·±åº¦è§£æ

### 1. AMM åŸç†

**ä¼ ç»Ÿåšå¸‚å•† vs AMM**:

```
ä¼ ç»Ÿåšå¸‚å•†ï¼š
- ä¹°å–å•ç°¿
- åšå¸‚å•†æä¾›æµåŠ¨æ€§
- ä»·æ ¼ç”±ä¹°å–å•å†³å®š
- éœ€è¦äººå·¥å¹²é¢„

AMMï¼š
- è‡ªåŠ¨åŒ–å®šä»·å…¬å¼
- æµåŠ¨æ€§æä¾›è€… (LP)
- ä»·æ ¼ç”±å…¬å¼è‡ªåŠ¨è®¡ç®—
- å®Œå…¨è‡ªåŠ¨åŒ–
```

### 2. Constant Product AMM (x*y=k)

**å…¬å¼**:
```
x * y = k

å…¶ä¸­ï¼š
- x: Token A æ•°é‡
- y: Token B æ•°é‡
- k: å¸¸æ•°ï¼ˆæµåŠ¨æ€§ï¼‰

å«ä¹‰ï¼š
- æµåŠ¨æ€§ä¸å˜æ—¶ï¼Œk ä¸å˜
- äº¤æ˜“æ—¶ï¼Œx å’Œ y å˜åŒ–ï¼Œä½† k ä¿æŒæ’å®š
- æ»‘ç‚¹ï¼šå¤§é¢äº¤æ˜“ä¼šæœ‰æ»‘ç‚¹
```

**ä»£ç å®ç°**:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract ConstantProductAMM {
    // ===================== çŠ¶æ€å˜é‡ =====================
    IERC20 public token0;
    IERC20 public token1;
    uint256 public reserve0;
    uint256 public reserve1;
    uint256 public totalLiquidity;

    // ===================== äº‹ä»¶ =====================
    event Mint(address indexed provider, uint256 amount0, uint256 amount1);
    event Burn(address indexed provider, uint256 amount0, uint256 amount1);
    event Swap(uint256 amount0In, uint256 amount1Out, address indexed to);

    // ===================== æ„é€ å‡½æ•° =====================
    constructor(address _token0, address _token1) {
        token0 = IERC20(_token0);
        token1 = IERC20(_token1);
    }

    // ===================== æ·»åŠ æµåŠ¨æ€§ =====================
    function addLiquidity(uint256 amount0, uint256 amount1) external {
        // è½¬å…¥ token
        token0.transferFrom(msg.sender, address(this), amount0);
        token1.transferFrom(msg.sender, address(this), amount1);

        // è®¡ç®—æ–°çš„å‚¨å¤‡é‡
        uint256 newReserve0 = reserve0 + amount0;
        uint256 newReserve1 = reserve1 + amount1;

        // é“¸é€ æµåŠ¨æ€§ä»£å¸
        uint256 liquidity = _calculateLiquidity(
            amount0, amount1,
            reserve0, reserve1
        );

        totalLiquidity += liquidity;

        // æ›´æ–°å‚¨å¤‡é‡
        reserve0 = newReserve0;
        reserve1 = newReserve1;

        emit Mint(msg.sender, amount0, amount1);
    }

    // ===================== ç§»é™¤æµåŠ¨æ€§ =====================
    function removeLiquidity(uint256 liquidity) external returns (uint256 amount0, uint256 amount1) {
        require(totalLiquidity >= liquidity, "Insufficient liquidity");

        // è®¡ç®—æå–çš„æ•°é‡
        uint256 amount0 = (reserve0 * liquidity) / totalLiquidity;
        uint256 amount1 = (reserve1 * liquidity) / totalLiquidity;

        // æ›´æ–°å‚¨å¤‡é‡
        reserve0 -= amount0;
        reserve1 -= amount1;
        totalLiquidity -= liquidity;

        // è½¬å‡º token
        token0.transfer(msg.sender, amount0);
        token1.transfer(msg.sender, amount1);

        emit Burn(msg.sender, amount0, amount1);

        return (amount0, amount1);
    }

    // ===================== äº¤æ¢ (æ ¸å¿ƒ) =====================
    function swap(
        uint256 amount0In,
        uint256 amount1In,
        uint256 amount0OutMin,
        uint256 amount1OutMin
    ) external returns (uint256 amount0Out, uint256 amount1Out) {
        require(amount0In > 0 || amount1In > 0, "Invalid input");

        // è®¡ç®—è¾“å‡ºé‡‘é¢ï¼ˆAMM æ ¸å¿ƒå…¬å¼ï¼‰
        if (amount0In > 0) {
            // è¾“å…¥ token0ï¼Œè¾“å‡º token1
            amount1Out = _getAmountOut(amount0In, reserve0, reserve1);
            require(amount1Out >= amount1OutMin, "Slippage too high");

            // æ›´æ–°å‚¨å¤‡é‡
            reserve0 += amount0In;
            reserve1 -= amount1Out;

            // è½¬å‡º token1
            token1.transfer(msg.sender, amount1Out);

            emit Swap(amount0In, amount1Out, msg.sender);
        } else {
            // è¾“å…¥ token1ï¼Œè¾“å‡º token0
            amount0Out = _getAmountOut(amount1In, reserve1, reserve0);
            require(amount0Out >= amount0OutMin, "Slippage too high");

            // æ›´æ–°å‚¨å¤‡é‡
            reserve1 += amount1In;
            reserve0 -= amount0Out;

            // è½¬å‡º token0
            token0.transfer(msg.sender, amount0Out);

            emit Swap(amount0Out, amount1In, msg.sender);
        }

        return (amount0Out, amount1Out);
    }

    // ===================== è¾…åŠ©å‡½æ•° =====================
    function _getAmountOut(
        uint256 amountIn,
        uint256 reserveIn,
        uint256 reserveOut
    ) private pure returns (uint256 amountOut) {
        // AMM æ ¸å¿ƒå…¬å¼ï¼šy = k / x
        // å®é™…è®¡ç®—ï¼šamountOut = (reserveOut * amountIn) / (reserveIn + amountIn)

        uint256 numerator = reserveOut * amountIn;
        uint256 denominator = reserveIn + amountIn;

        return numerator / denominator;
    }

    function _calculateLiquidity(
        uint256 amount0,
        uint256 amount1,
        uint256 _reserve0,
        uint256 _reserve1
    ) private view returns (uint256 liquidity) {
        // è®¡ç®—æµåŠ¨æ€§ä»£å¸æ•°é‡
        // ç®€åŒ–ï¼šliquidity = min(amount0 / reserve0, amount1 / reserve1) * totalLiquidity

        uint256 liquidity0 = _reserve0 == 0 ? amount0 : (amount0 * totalLiquidity) / _reserve0;
        uint256 liquidity1 = _reserve1 == 0 ? amount1 : (amount1 * totalLiquidity) / _reserve1;

        return liquidity0 < liquidity1 ? liquidity0 : liquidity1;
    }

    // ===================== æŸ¥è¯¢å‡½æ•° =====================
    function getReserves() external view returns (uint256 _reserve0, uint256 _reserve1) {
        return (reserve0, reserve1);
    }

    function getAmountOut(uint256 amountIn, address tokenIn) external view returns (uint256) {
        if (tokenIn == address(token0)) {
            return _getAmountOut(amountIn, reserve0, reserve1);
        } else {
            return _getAmountOut(amountIn, reserve1, reserve0);
        }
    }
}
```

**AMM æ ¸å¿ƒå…¬å¼**:
```solidity
// è®¡ç®—è¾“å‡ºé‡‘é¢
amountOut = (reserveOut * amountIn) / (reserveIn + amountIn)

// ç¤ºä¾‹ï¼š
// reserve0 = 1000 ETH, reserve1 = 2000 USDC
// è¾“å…¥ 100 ETH
// amountOut = (2000 * 100) / (1000 + 100) = 181.8 USDC

// æ›´æ–°å‚¨å¤‡é‡ï¼š
// reserve0 = 1100 ETH, reserve1 = 1818.2 USDC
// éªŒè¯ï¼š1100 * 1818.2 = 1,999, â‰ˆ 1000 * 2000 = 2,000,000
```

### 3. æ»‘ç‚¹ (Slippage)

**æ»‘ç‚¹åŸå› **:
- æµåŠ¨æ€§ä¸è¶³æ—¶ï¼Œå¤§é¢äº¤æ˜“ä¼šæ˜¾è‘—å½±å“ä»·æ ¼
- AMM å…¬å¼çš„å›ºæœ‰é—®é¢˜

**æ»‘ç‚¹è®¡ç®—**:
```solidity
// æœ€å°è¾“å‡ºé‡‘é¢ = ç†è®ºè¾“å‡º * (1 - æ»‘ç‚¹å®¹å¿åº¦)
uint256 amountOutMin = amountOut * (100 - slippage) / 100;

// ç¤ºä¾‹ï¼š
// ç†è®ºè¾“å‡º = 100 USDC
// æ»‘ç‚¹å®¹å¿åº¦ = 1% (1)
// æœ€å°è¾“å‡º = 100 * 0.99 = 99 USDC
```

### 4. AMM ä¼˜åŒ–

**ä¼˜åŒ–ç­–ç•¥**:

```solidity
// ===================== ä¼˜åŒ– 1: ç²¾ç¡®è®¡ç®— =====================
// ä½¿ç”¨ Solidity 0.8+ çš„ç²¾ç¡®è®¡ç®—åº“
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

using SafeMath for uint256;

// ===================== ä¼˜åŒ– 2: é—ªç”µäº¤æ¢ =====================
function flashSwap(
    uint256 amountIn,
    uint256 amountOutMin,
    address borrower
) external returns (uint256 amountOut) {
    // 1. å€Ÿå…¥ token
    token.transferFrom(msg.sender, address(this), amountIn);

    // 2. æ‰§è¡Œäº¤æ¢
    amountOut = _getAmountOut(amountIn, reserveIn, reserveOut);

    // 3. å€Ÿå‡º token ç»™å€Ÿæ¬¾äºº
    token.transfer(borrower, amountOut);

    // 4. è¦æ±‚å€Ÿæ¬¾äººè¿˜æ¬¾
    // å¿…é¡»åœ¨åŒä¸€ä¸ªäº¤æ˜“å†…è¿˜æ¬¾

    // 5. å€Ÿæ¬¾äººæ‰§è¡Œè‡ªå®šä¹‰é€»è¾‘
    // ä¾‹å¦‚ï¼šå¥—åˆ©ã€å€Ÿè´·

    // 6. è¦æ±‚å€Ÿæ¬¾äººå½’è¿˜ token
    token.transferFrom(borrower, address(this), amountIn);

    // 7. æ›´æ–°å‚¨å¤‡é‡
    reserveIn += amountIn;
    reserveOut -= amountOut;
}

// ===================== ä¼˜åŒ– 3: å¤šè·¯å¾„è·¯ç”± =====================
function multiHopSwap(
    address[] calldata path,
    uint256 amountIn,
    uint256 amountOutMin
) external returns (uint256) {
    // éå†è·¯å¾„ï¼Œå¤šæ¬¡äº¤æ¢
    uint256 amount = amountIn;

    for (uint256 i = 0; i < path.length - 1; ++i) {
        (amount, ) = swap(
            path[i],
            path[i + 1],
            amount,
            0
        );
    }

    require(amount >= amountOutMin, "Insufficient output");

    return amount;
}
```

---

## ğŸ’³ å€Ÿè´·åè®®æ·±åº¦è§£æ

### 1. æ ¸å¿ƒæœºåˆ¶

**å€Ÿè´·æµç¨‹**:

```
1. å­˜æ¬¾
   å€Ÿæ¬¾äºº â†’ èµ„é‡‘æ±  â†’ æ™ºèƒ½åˆçº¦
   â†‘ èµšå–åˆ©æ¯æ”¶ç›Š

2. å€Ÿæ¬¾
   å€Ÿæ¬¾äºº â†’ æ™ºèƒ½åˆçº¦ â†’ èµ„é‡‘æ± 
   â†‘ éœ€è¦æŠµæŠ¼
   â†‘ æ”¯ä»˜åˆ©æ¯

3. æ¸…ç®—
   æ¸…ç®—äºº â†’ æ™ºèƒ½åˆçº¦ â†’ æŠµæŠ¼å“
   â†‘ å¿è¿˜å€ºåŠ¡
   â†‘ è·å¾—æ¸…ç®—å¥–åŠ±
```

### 2. æ™ºèƒ½åˆçº¦å®ç°

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

contract LendingPool is ReentrancyGuard {
    // ===================== çŠ¶æ€å˜é‡ =====================
    IERC20 public asset;              // å€Ÿè´·èµ„äº§ï¼ˆå¦‚ USDCï¼‰
    uint256 public totalDeposited;      // æ€»å­˜æ¬¾é‡
    uint256 public totalBorrowed;       // æ€»å€Ÿæ¬¾é‡

    // å­˜æ¬¾ä¿¡æ¯
    mapping(address => uint256) public deposited;
    mapping(address => uint256) public depositIndex;

    // å€Ÿæ¬¾ä¿¡æ¯
    mapping(address => uint256) public borrowed;
    mapping(address => uint256) public collateral;  // æŠµæŠ¼å“ä»·å€¼

    // åˆ©ç‡
    uint256 public borrowRate = 5 * 10**15 / 100;  // 5% å¹´åŒ–åˆ©ç‡
    uint256 public supplyRate = 2 * 10**15 / 100;   // 2% å¹´åŒ–åˆ©ç‡

    // æ¸…ç®—å‚æ•°
    uint256 public liquidationThreshold = 85;  // æ¸…ç®—çº¿ 85%
    uint256 public liquidationBonus = 5;       // æ¸…ç®—å¥–åŠ± 5%

    // ===================== äº‹ä»¶ =====================
    event Deposit(address indexed user, uint256 amount);
    event Withdraw(address indexed user, uint256 amount);
    event Borrow(address indexed user, uint256 amount);
    event Repay(address indexed user, uint256 amount);
    event Liquidate(address indexed user, address indexed liquidator, uint256 amount);

    // ===================== æ„é€ å‡½æ•° =====================
    constructor(address _asset) {
        asset = IERC20(_asset);
    }

    // ===================== å­˜æ¬¾ =====================
    function deposit(uint256 amount) external nonReentrant {
        // è½¬å…¥èµ„äº§
        asset.transferFrom(msg.sender, address(this), amount);

        // è®¡ç®—åˆ©æ¯
        uint256 interest = _calculateInterest(deposited[msg.sender], depositIndex[msg.sender]);

        // æ›´æ–°å­˜æ¬¾
        deposited[msg.sender] += amount + interest;
        depositIndex[msg.sender] = block.timestamp;
        totalDeposited += amount + interest;

        emit Deposit(msg.sender, amount);
    }

    // ===================== å–æ¬¾ =====================
    function withdraw(uint256 amount) external nonReentrant {
        require(deposited[msg.sender] >= amount, "Insufficient balance");

        // è®¡ç®—åˆ©æ¯
        uint256 interest = _calculateInterest(deposited[msg.sender], depositIndex[msg.sender]);

        // æ›´æ–°å­˜æ¬¾
        deposited[msg.sender] -= amount;
        totalDeposited -= amount;

        // è½¬å‡ºèµ„äº§ + åˆ©æ¯
        asset.transfer(msg.sender, amount + interest);

        emit Withdraw(msg.sender, amount);
    }

    // ===================== å€Ÿæ¬¾ =====================
    function borrow(uint256 amount, uint256 collateralAmount) external nonReentrant {
        // è¦æ±‚è¶³å¤Ÿçš„æŠµæŠ¼
        require(collateralAmount >= amount * 100 / liquidationThreshold, "Insufficient collateral");

        // è½¬å…¥æŠµæŠ¼å“
        // å®é™…å®ç°ä¸­ï¼ŒæŠµæŠ¼å“å¯èƒ½æ˜¯å¦ä¸€ç§ä»£å¸ï¼ˆå¦‚ ETHï¼‰
        // è¿™é‡Œç®€åŒ–å¤„ç†

        // æ›´æ–°å€Ÿæ¬¾
        borrowed[msg.sender] += amount;
        collateral[msg.sender] += collateralAmount;
        totalBorrowed += amount;

        // è½¬å‡ºå€Ÿæ¬¾èµ„äº§
        asset.transfer(msg.sender, amount);

        emit Borrow(msg.sender, amount);
    }

    // ===================== è¿˜æ¬¾ =====================
    function repay(uint256 amount) external nonReentrant {
        require(borrowed[msg.sender] >= amount, "No debt to repay");

        // è®¡ç®—åˆ©æ¯
        uint256 interest = _calculateInterest(borrowed[msg.sender], block.timestamp - 1 days);

        // æ›´æ–°å€Ÿæ¬¾
        borrowed[msg.sender] -= amount;
        totalBorrowed -= amount;

        // è½¬å…¥è¿˜æ¬¾èµ„äº§ + åˆ©æ¯
        asset.transferFrom(msg.sender, address(this), amount + interest);

        emit Repay(msg.sender, amount);
    }

    // ===================== æ¸…ç®— =====================
    function liquidate(address borrower, uint256 amount) external nonReentrant {
        // æ£€æŸ¥æ˜¯å¦å¯ä»¥æ¸…ç®—
        uint256 debt = borrowed[borrower];
        require(debt > 0, "No debt to liquidate");
        require(collateral[borrower] < debt * 100 / liquidationThreshold, "Not liquidatable");

        // é™åˆ¶æ¸…ç®—é‡‘é¢
        uint256 maxLiquidation = debt * (100 - liquidationThreshold) / 100;
        require(amount <= maxLiquidation, "Liquidation amount too high");

        // è¿˜æ¬¾
        asset.transferFrom(msg.sender, address(this), amount);

        // æ›´æ–°å€Ÿæ¬¾
        borrowed[borrower] -= amount;
        totalBorrowed -= amount;

        // è½¬å‡ºæŠµæŠ¼å“ç»™æ¸…ç®—äººï¼ˆåŒ…å«æ¸…ç®—å¥–åŠ±ï¼‰
        uint256 collateralOut = amount * (100 + liquidationBonus) / 100;
        // å®é™…å®ç°ä¸­ï¼Œè½¬å‡ºæŠµæŠ¼å“ä»£å¸

        emit Liquidate(borrower, msg.sender, amount);
    }

    // ===================== è¾…åŠ©å‡½æ•° =====================
    function _calculateInterest(
        uint256 principal,
        uint256 startTime
    ) private view returns (uint256) {
        // ç®€åŒ–ï¼šå¹´åŒ–åˆ©ç‡ * æ—¶é—´ / 365 å¤©
        uint256 timeElapsed = block.timestamp - startTime;
        return principal * borrowRate * timeElapsed / (365 days * 10**15);
    }

    // ===================== æŸ¥è¯¢å‡½æ•° =====================
    function getBalance(address user) external view returns (uint256) {
        uint256 interest = _calculateInterest(deposited[user], depositIndex[user]);
        return deposited[user] + interest;
    }

    function getDebt(address user) external view returns (uint256) {
        uint256 interest = _calculateInterest(borrowed[user], block.timestamp - 1 days);
        return borrowed[user] + interest;
    }
}
```

### 3. å…³é”®é£é™©æ§åˆ¶

**æ¸…ç®—æœºåˆ¶**:
```
æŠµæŠ¼ç‡ (LTV) = å€Ÿæ¬¾é‡‘é¢ / æŠµæŠ¼å“ä»·å€¼

æ¸…ç®—çº¿ï¼š
- LTV > 85% æ—¶è§¦å‘æ¸…ç®—
- æ¸…ç®—äººå¿è¿˜å€ºåŠ¡
- æ¸…ç®—äººè·å¾—æŠµæŠ¼å“ + 5% å¥–åŠ±

ç¤ºä¾‹ï¼š
- å€Ÿæ¬¾ï¼š100 USDC
- æŠµæŠ¼å“ï¼š120 USDC
- LTV = 100 / 120 = 83.3%
- æœªè¾¾åˆ°æ¸…ç®—çº¿ (85%)

å¦‚æœæŠµæŠ¼å“è·Œåˆ°ï¼š
- æŠµæŠ¼å“ï¼š110 USDC
- LTV = 100 / 110 = 90.9%
- è¾¾åˆ°æ¸…ç®—çº¿ï¼Œå¯ä»¥è¢«æ¸…ç®—
```

---

## âš¡ é—ªç”µè´· (Flash Loan) æ·±åº¦è§£æ

### 1. é—ªç”µè´·åŸç†

**é—ªç”µè´·** - åœ¨åŒä¸€ä¸ªäº¤æ˜“å†…å€Ÿæ¬¾ã€ä½¿ç”¨ã€è¿˜æ¬¾ã€‚

```
é—ªç”µè´·æµç¨‹ï¼š
1. å€Ÿæ¬¾
   ä» Aave å€Ÿå…¥ 1000 USDC
   â†‘ æ— æŠµæŠ¼å“

2. ä½¿ç”¨
   åœ¨ Uniswap å¥—åˆ©
   æˆ–åœ¨ Compound å­˜æ¬¾

3. è¿˜æ¬¾
   å½’è¿˜ 1000 USDC + æ‰‹ç»­è´¹
   â†‘ å¿…é¡»åœ¨åŒä¸€ä¸ªäº¤æ˜“å†…

4. åˆ©æ¶¦
   å¥—åˆ©æ”¶ç›Š - æ‰‹ç»­è´¹
```

### 2. æ™ºèƒ½åˆçº¦å®ç°

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

contract FlashLoan is ReentrancyGuard {
    // ===================== çŠ¶æ€å˜é‡ =====================
    IERC20 public lendingToken;
    address public lendingPool;  // Aave/Compound åœ°å€

    // ===================== äº‹ä»¶ =====================
    event FlashLoan(address indexed borrower, uint256 amount, uint256 fee);
    event Arbitrage(uint256 profit);

    // ===================== æ„é€ å‡½æ•° =====================
    constructor(address _lendingToken, address _lendingPool) {
        lendingToken = IERC20(_lendingToken);
        lendingPool = _lendingPool;
    }

    // ===================== é—ªç”µè´· =====================
    function flashLoan(uint256 amount, address target, bytes calldata data) external nonReentrant {
        // 1. å€Ÿæ¬¾ï¼ˆæ— æŠµæŠ¼å“ï¼‰
        // å®é™…å®ç°ä¸­ï¼Œè°ƒç”¨ Aave/Compound çš„é—ªç”µè´·å‡½æ•°
        lendingToken.transferFrom(lendingPool, address(this), amount);

        // 2. æ‰§è¡Œè‡ªå®šä¹‰é€»è¾‘
        // å€Ÿæ¬¾äººæ‰§è¡Œå¥—åˆ©ã€å¥—æœŸç­‰ç­–ç•¥
        (bool success, ) = target.call(data);
        require(success, "Target call failed");

        // 3. è¿˜æ¬¾ï¼ˆå¿…é¡»åŒ…å«æ‰‹ç»­è´¹ï¼‰
        uint256 fee = amount * 3 / 10000;  // 0.03% æ‰‹ç»­è´¹
        uint256 repayAmount = amount + fee;

        lendingToken.transfer(lendingPool, repayAmount);

        // 4. è½¬å‡ºåˆ©æ¶¦
        uint256 profit = lendingToken.balanceOf(address(this)) - repayAmount;
        lendingToken.transfer(msg.sender, profit);

        emit FlashLoan(msg.sender, amount, fee);
        if (profit > 0) {
            emit Arbitrage(profit);
        }
    }

    // ===================== å¥—åˆ©å‡½æ•° =====================
    function arbitrage(
        uint256 amount,
        address[] calldata path,
        uint256 minProfit
    ) external returns (uint256 profit) {
        // 1. é—ªç”µè´·
        flashLoan(amount, address(this), abi.encodeWithSelector(this.executeArbitrage.selector, path));

        // 2. æ‰§è¡Œå¥—åˆ©
        // ï¼ˆåœ¨é—ªç”µè´·å›è°ƒä¸­æ‰§è¡Œï¼‰

        // 3. æ£€æŸ¥åˆ©æ¶¦
        require(profit >= minProfit, "Insufficient profit");

        return profit;
    }

    // ===================== æ‰§è¡Œå¥—åˆ© =====================
    function executeArbitrage(address[] calldata path) external {
        require(msg.sender == address(this), "Unauthorized");

        // 1. ä» Aave/Compound å€Ÿæ¬¾
        uint256 amount = lendingToken.balanceOf(address(this));

        // 2. å¤šè·¯å¾„äº¤æ¢ï¼ˆUniswap, SushiSwap, PancakeSwapï¼‰
        uint256 currentAmount = amount;

        for (uint256 i = 0; i < path.length - 1; ++i) {
            // è°ƒç”¨ DEX äº¤æ¢
            (currentAmount, ) = _swapOnDEX(path[i], path[i + 1], currentAmount);
        }

        // 3. è¿˜æ¬¾
        uint256 fee = amount * 3 / 10000;
        uint256 repayAmount = amount + fee;

        require(currentAmount >= repayAmount, "Arbitrage failed");

        lendingToken.transfer(lendingPool, repayAmount);
    }

    // ===================== è¾…åŠ©å‡½æ•° =====================
    function _swapOnDEX(
        address dex,
        address tokenIn,
        address tokenOut,
        uint256 amountIn
    ) private returns (uint256 amountOut) {
        // è°ƒç”¨ DEX çš„ swap å‡½æ•°
        // å®é™…å®ç°ä¸­ï¼Œè°ƒç”¨ Uniswap/SushiSwap çš„ router
        // è¿™é‡Œç®€åŒ–å¤„ç†
        return amountIn * 99 / 100;  // å‡è®¾ 1% æ»‘ç‚¹
    }
}
```

### 3. å¥—åˆ©ç¤ºä¾‹

**ä¸‰è§’å¥—åˆ©**:

```
ä»·æ ¼å·®å¼‚ï¼š
- Uniswap: 1 ETH = 2000 USDC
- SushiSwap: 1 ETH = 2010 USDC
- PancakeSwap: 1 ETH = 1990 USDC

å¥—åˆ©è·¯å¾„ï¼š
1. é—ªç”µè´· 1 ETH
2. SushiSwap å–å‡ºï¼š1 ETH â†’ 2010 USDC
3. Uniswap ä¹°å…¥ï¼š2010 USDC â†’ 1.005 ETH
4. è¿˜æ¬¾ 1 ETH + æ‰‹ç»­è´¹
5. åˆ©æ¶¦ï¼š0.005 ETH = $10
```

---

## ğŸ” DeFi å®‰å…¨æœ€ä½³å®è·µ

### 1. é‡å…¥æ”»å‡»é˜²æŠ¤

```solidity
// ä½¿ç”¨ ReentrancyGuard
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

contract MyContract is ReentrancyGuard {
    mapping(address => uint256) public balances;

    function withdraw() external nonReentrant {
        uint256 amount = balances[msg.sender];
        require(amount > 0, "No balance");

        // 1. å…ˆæ›´æ–°çŠ¶æ€
        balances[msg.sender] = 0;

        // 2. å†æ‰§è¡Œå¤–éƒ¨è°ƒç”¨
        payable(msg.sender).transfer(amount);

        // nonReentrant ç¡®ä¿å‡½æ•°ä¸èƒ½è¢«é‡å…¥
    }
}
```

### 2. æ•´æ•°æº¢å‡ºé˜²æŠ¤

```solidity
// ä½¿ç”¨ Solidity 0.8.0+ è‡ªåŠ¨æ£€æŸ¥æº¢å‡º
// æˆ–ä½¿ç”¨ SafeMath åº“
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

using SafeMath for uint256;

function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {
    return a.add(b);  // è‡ªåŠ¨æ£€æŸ¥æº¢å‡º
}
```

### 3. é—ªç”µè´·æ”»å‡»é˜²æŠ¤

```solidity
// æ£€æŸ¥-æ•ˆæœ-äº¤äº’æ¨¡å¼
contract MyContract {
    uint256 public totalSupply;

    function mint(uint256 amount) external {
        // 1. å…ˆè®°å½•å¿«ç…§
        uint256 oldBalance = balanceOf(msg.sender);

        // 2. æ‰§è¡Œé“¸é€ 
        _mint(msg.sender, amount);

        // 3. æ£€æŸ¥æ•ˆæœ
        require(balanceOf(msg.sender) == oldBalance + amount, "Mint failed");
    }

    function _mint(address to, uint256 amount) internal {
        totalSupply += amount;
        balances[to] += amount;
    }
}
```

---

## ğŸ’° DeFi å•†ä¸šæ¨¡å¼

### 1. æ‰‹ç»­è´¹æ”¶å…¥

```
äº¤æ˜“æ‰‹ç»­è´¹æ”¶å…¥ï¼š

å…¬å¼ï¼š
æ”¶å…¥ = TVL * è½¬åŒ–ç‡ * æ‰‹ç»­è´¹ç‡

ç¤ºä¾‹ï¼š
- TVL: $1000ä¸‡
- æ—¥è½¬åŒ–ç‡: 2%
- æ‰‹ç»­è´¹ç‡: 0.3%
- æ—¥æ”¶å…¥: $1000ä¸‡ * 2% * 0.3% = $600
- æœˆæ”¶å…¥: $600 * 30 = $18,000
- å¹´æ”¶å…¥: $18,000 * 12 = $216,000
```

### 2. æµåŠ¨æ€§æŒ–çŸ¿

```
æµåŠ¨æ€§æŒ–çŸ¿å¥–åŠ±ï¼š

å…¬å¼ï¼š
å¥–åŠ± = æµåŠ¨æ€§å æ¯” * æ€»å¥–åŠ±

ç¤ºä¾‹ï¼š
- æ€»æµåŠ¨æ€§: $1000ä¸‡
- ç”¨æˆ·æµåŠ¨æ€§: $10ä¸‡ (10%)
- æ—¥å¥–åŠ±: 1000 ä»£å¸
- ç”¨æˆ·å¥–åŠ±: 1000 * 10% = 100 ä»£å¸
- æœˆå¥–åŠ±: 100 * 30 = 3000 ä»£å¸
```

### 3. æ²»ç†ä»£å¸ä»·å€¼

```
æ²»ç†ä»£å¸ä»·å€¼ï¼š

å…¬å¼ï¼š
å¸‚å€¼ = ä»£å¸ä¾›åº”é‡ * ä»£å¸ä»·æ ¼

ç¤ºä¾‹ï¼š
- UNI ä¾›åº”é‡: 10 äº¿
- UNI ä»·æ ¼: $10
- å¸‚å€¼: $100 äº¿

é¡¹ç›®æ”¶å…¥ï¼š
- ä»£å¸å‡å€¼ + æ‰‹ç»­è´¹æ”¶å…¥
```

---

## ğŸ¯ å¦‚ä½•åŸºäº DeFi åˆ›ä¸š

### æ–¹å‘ 1: DEX åè®® â­â­â­â­â­â­

**æ­¥éª¤**:
1. Phase 1: MVP (1-2 ä¸ªæœˆ)
   - å®ç° AMM
   - åŸºç¡€æµåŠ¨æ€§
   - äº¤æ˜“åŠŸèƒ½

2. Phase 2: å¢å¼ºåŠŸèƒ½ (2-3 ä¸ªæœˆ)
   - å¤šä»£å¸å¯¹
   - æµåŠ¨æ€§æŒ–çŸ¿
   - æ²»ç†ä»£å¸

3. Phase 3: è§„æ¨¡åŒ– (3-6 ä¸ªæœˆ)
   - é—ªç”µè´·
   - å¤šè·¯å¾„è·¯ç”±
   - è·¨é“¾äº¤æ¢

**é¢„æœŸæ”¶å…¥**: $10ä¸‡ - $100ä¸‡/æœˆ

### æ–¹å‘ 2: å€Ÿè´·åè®® â­â­â­â­â­

**æ­¥éª¤**:
1. Phase 1: MVP (1-2 ä¸ªæœˆ)
   - åŸºç¡€å­˜æ¬¾/å€Ÿæ¬¾
   - å•èµ„äº§æ± 
   - åˆ©ç‡è®¡ç®—

2. Phase 2: å¢å¼ºåŠŸèƒ½ (2-3 ä¸ªæœˆ)
   - å¤šèµ„äº§æ”¯æŒ
   - é—ªç”µè´·
   - æ¸…ç®—æœºåˆ¶

3. Phase 3: è§„æ¨¡åŒ– (3-6 ä¸ªæœˆ)
   - é£é™©æ§åˆ¶
   - ä¿¡ç”¨è¯„åˆ†
   - è¡ç”Ÿå“äº¤æ˜“

**é¢„æœŸæ”¶å…¥**: $5ä¸‡ - $50ä¸‡/æœˆ

### æ–¹å‘ 3: èšåˆå™¨ â­â­â­â­

**æ­¥éª¤**:
1. Phase 1: MVP (1-2 ä¸ªæœˆ)
   - é›†æˆå¤šä¸ª DEX
   - æœ€ä¼˜è·¯å¾„æŸ¥æ‰¾
   - åŸºç¡€èšåˆ

2. Phase 2: å¢å¼ºåŠŸèƒ½ (2-3 ä¸ªæœˆ)
   - è‡ªåŠ¨æ»‘ç‚¹ä¿æŠ¤
   - å¤šé“¾æ”¯æŒ
   - æ”¶ç›Šä¼˜åŒ–

3. Phase 3: è§„æ¨¡åŒ– (3-6 ä¸ªæœˆ)
   - æ”¶ç›Šèšåˆå™¨
   - æ²»ç†ä»£å¸
   - å¥–åŠ±è®¡åˆ’

**é¢„æœŸæ”¶å…¥**: $20ä¸‡ - $200ä¸‡/æœˆ

---

## ğŸ“Š DeFi é¡¹ç›®å¯¹æ¯”

| é¡¹ç›® | ç±»å‹ | TVL | å¹´æ”¶å…¥ | ç‰¹ç‚¹ |
|--------|------|----------|--------|
| **Uniswap** | DEX | $50äº¿+ | $1000ä¸‡+ | å…ˆå‘è€…ã€AMM åˆ›æ–° |
| **Aave** | å€Ÿè´· | $80äº¿+ | $500ä¸‡+ | å¤šé“¾ã€é—ªç”µè´· |
| **Curve** | DEX | $30äº¿+ | $300ä¸‡+ | ç¨³å®šå¸ä¼˜åŒ– |
| **1inch** | èšåˆå™¨ | $10äº¿+ | $200ä¸‡+ | æœ€ä¼˜è·¯å¾„ã€å¤šé“¾ |
| **Yearn** | èšåˆå™¨ | $5äº¿+ | $100ä¸‡+ | è‡ªåŠ¨æ”¶ç›Šä¼˜åŒ– |

---

## ğŸ“ˆ æ€»ç»“

**DeFi æ˜¯ä»€ä¹ˆï¼Ÿ**
- åŸºäºåŒºå—é“¾çš„é‡‘èæœåŠ¡
- æ— éœ€ä¸­å¿ƒåŒ–ä¸­ä»‹
- ä»£ç å³æ³•å¾‹ï¼ˆCode is Lawï¼‰

**æ ¸å¿ƒèµ›é“**:
- DEXï¼ˆå»ä¸­å¿ƒåŒ–äº¤æ˜“æ‰€ï¼‰
- å€Ÿè´·åè®®
- ç¨³å®šå¸
- è·¨é“¾æ¡¥
- èšåˆå™¨
- é—ªç”µè´·

**æœ€èµšé’±çš„èµ›é“ï¼Ÿ**
- DEXï¼šå¸‚åœºè§„æ¨¡æœ€å¤§ ($100+ äº¿)
- å€Ÿè´·ï¼šç¨³å®šæ”¶å…¥æ¥æº ($60+ äº¿)
- èšåˆå™¨ï¼šé«˜æŠ€æœ¯é—¨æ§›ï¼Œé«˜åˆ©æ¶¦ ($50+ äº¿)

**å¦‚ä½•å¼€å§‹ï¼Ÿ**
1. å­¦ä¹  Solidity å’Œ AMM åŸç†
2. å®ç° MVPï¼ˆå¦‚ç®€å• AMMï¼‰
3. æ·»åŠ æµåŠ¨æ€§å’Œç”¨æˆ·
4. è§„æ¨¡åŒ–å’Œå•†ä¸šåŒ–

---

**ä¸‹ä¸€æ­¥ï¼šéœ€è¦æˆ‘å¸®ä½ è§„åˆ’å…·ä½“çš„ DeFi é¡¹ç›®å®æ–½è®¡åˆ’å—ï¼Ÿ**
