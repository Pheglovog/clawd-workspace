# ç¬¬åå°æ—¶ï¼šDeFi Lending åè®®æ·±åº¦ç ”ç©¶

> ä¸»åŠ¨è¿›åŒ–å­¦ä¹  ğŸªµ â†’ ğŸ’ª
> åŸºäº MCP æœç´¢çš„ 2026 å¹´æœ€æ–°è¶‹åŠ¿

---

## ä¸‰åä¸‰ã€DeFi Lending åè®®æ¦‚è§ˆ

### 33.1 Lending åè®®åˆ†ç±»

```
DeFi Lending åè®®ç±»å‹ï¼š

1. Over-collateralizedï¼ˆè¶…é¢æŠµæŠ¼ï¼‰
   - è¦æ±‚æŠµæŠ¼å“ä»·å€¼ > å€Ÿæ¬¾ä»·å€¼
   - ä¾‹ï¼šAave, Compound, MakerDAO
   - æŠµæŠ¼ç‡ï¼šé€šå¸¸ 110-150%

2. Under-collateralizedï¼ˆä½æŠµæŠ¼ï¼‰
   - æ— éœ€æŠµæŠ¼æˆ–ä½æŠµæŠ¼
   - ä¾‹ï¼šTrueFi, Goldfinch
   - ä¾èµ–ä¿¡ç”¨è¯„åˆ†

3. Peer-to-Peerï¼ˆç‚¹å¯¹ç‚¹ï¼‰
   - ç›´æ¥å¯¹æ¥å€Ÿæ–¹å’Œè´·æ–¹
   - ä¾‹ï¼šTeller, Aave Arc
   - éœ€è¦ä¿¡ç”¨è¯„ä¼°

4. Money Marketï¼ˆè´§å¸å¸‚åœºï¼‰
   - åŸºäºç®—æ³•çš„åˆ©ç‡
   - ä¾‹ï¼šAave, Compound
   - åˆ©ç‡éšä¾›éœ€åŠ¨æ€è°ƒæ•´
```

### 33.2 Aave V3 æ·±åº¦è§£æ

**æ ¸å¿ƒåˆ›æ–°ï¼š**

```
Aave V3 æ–°ç‰¹æ€§ï¼š

1. Portfoliosï¼ˆæŠ•èµ„ç»„åˆç®¡ç†ï¼‰
   - æœ€å¤š 20 ä¸ªä»“ä½
   - åˆ†ç±»ç®¡ç†
   - é£é™©éš”ç¦»

2. Isolation Modeï¼ˆéš”ç¦»æ¨¡å¼ï¼‰
   - é’ˆå¯¹ç‰¹å®šèµ„äº§
   - é™ä½ç³»ç»Ÿæ€§é£é™©
   - æ›´ä¸¥æ ¼çš„å‚æ•°

3. Efficiency Modeï¼ˆæ•ˆç‡æ¨¡å¼ï¼‰
   - é«˜æŠµæŠ¼ç‡
   - æ›´é«˜æ æ†
   - æ›´é«˜èµ„é‡‘æ•ˆç‡

4. Multi-collateralï¼ˆå¤šèµ„äº§æŠµæŠ¼ï¼‰
   - æ”¯æŒå¤šå¸ç§æŠµæŠ¼
   - ä¼˜åŒ–èµ„æœ¬æ•ˆç‡
   - çµæ´»å€Ÿè´·

5. Non-EVM Chainsï¼ˆé EVM é“¾ï¼‰
   - æ”¯æŒ zkSync, Scroll, Linea
   - æ‰©å±•ç”Ÿæ€
```

**Portfolios å®ç°ç¤ºä¾‹ï¼š**

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

/**
 * @title Aave V3 Portfolios é›†æˆ
 * @author ä¸Šç­‰å…µâ€¢ç”˜
 */
contract AaveV3PortfoliosIntegration {
    using SafeERC20 for IERC20;

    // ========== æ¥å£ ==========
    interface IPoolAddressesProvider {
        function getPool() external view returns (address);
    }

    interface IPool {
        struct SupplyParams {
            address asset;
            uint256 amount;
            address onBehalfOf;
            uint16 referralCode;
        }

        struct BorrowParams {
            uint16 interestRateMode;
            address asset;
            uint256 amount;
            uint256 interestRateMode;
            address onBehalfOf;
            uint16 referralCode;
        }

        struct RepayParams {
            uint256 interestRateMode;
            address asset;
            uint256 amount;
            address onBehalfOf;
            uint256 interestRateMode;
            uint256 interestRateMode;
        }

        function supply(SupplyParams calldata params) external;
        function supplyWithPermit(SupplyParams calldata params, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;
        function borrow(BorrowParams calldata params) external;
        function repay(RepayParams calldata params) external;
        function getUserAccountData(
            address user,
            uint256[] calldata interestRateModes
        )
            external
            view
            returns (
                uint256 totalCollateralBase,
                uint256 totalDebtBase,
                uint256 currentLiquidationThreshold,
                uint256 ltvs,
                uint256 healthFactor
            );
    }

    interface IPoolV3 {
        struct SupplyParams {
            address asset;
            uint256 amount;
            address onBehalfOf;
            uint16 referralCode;
        }

        function supply(
            address asset,
            uint256 amount,
            address onBehalfOf,
            uint16 referralCode
        ) external;
    }

    // ========== å¸¸é‡ ==========
    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address public constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address public constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;

    IPoolAddressesProvider public constant ADDRESSES_PROVIDER =
        IPoolAddressesProvider(0xa97684ead0e17de93eb646b8a3c2d8706461b0b6);

    IPool public immutable pool;

    // ========== çŠ¶æ€å˜é‡ ==========
    address public owner;
    mapping(address => uint256) public portfolioBalances;

    // ========== äº‹ä»¶ ==========
    event Supplied(address indexed user, address indexed asset, uint256 amount, uint256 portfolioId);
    event Borrowed(address indexed user, address indexed asset, uint256 amount, uint256 portfolioId);
    event Repaid(address indexed user, address indexed asset, uint256 amount, uint256 portfolioId);

    // ========== ä¿®é¥°ç¬¦ ==========
    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner");
        _;
    }

    // ========== æ„é€ å‡½æ•° ==========
    constructor() {
        pool = IPool(ADDRESSES_PROVIDER.getPool());
        owner = msg.sender;
    }

    // ========== æ ¸å¿ƒåŠŸèƒ½ ==========

    /**
     * @dev ä¾›åº”èµ„äº§åˆ° Portfolio
     * @param asset èµ„äº§åœ°å€
     * @param amount é‡‘é¢
     * @param portfolioId Portfolio ID
     */
    function supplyToPortfolio(
        address asset,
        uint256 amount,
        uint256 portfolioId
    ) external {
        require(amount > 0, "Amount must be > 0");

        IERC20(asset).safeTransferFrom(msg.sender, address(this), amount);
        IERC20(asset).safeApprove(address(pool), amount);

        pool.supply(asset, amount, address(this), 0);

        portfolioBalances[address(this)] += amount;

        emit Supplied(msg.sender, asset, amount, portfolioId);
    }

    /**
     * @dev ä» Portfolio å€Ÿæ¬¾
     * @param asset èµ„äº§åœ°å€
     * @param amount é‡‘é¢
     * @param interestRateMode åˆ©ç‡æ¨¡å¼
     * @param portfolioId Portfolio ID
     */
    function borrowFromPortfolio(
        address asset,
        uint256 amount,
        uint256 interestRateMode,
        uint256 portfolioId
    ) external {
        require(amount > 0, "Amount must be > 0");

        IPool.BorrowParams memory params = IPool.BorrowParams({
            interestRateMode: uint16(interestRateMode),
            asset: asset,
            amount: amount,
            interestRateMode: uint16(interestRateMode),
            onBehalfOf: address(this),
            referralCode: 0
        });

        pool.borrow(params);

        emit Borrowed(msg.sender, asset, amount, portfolioId);
    }

    /**
     * @dev è¿˜æ¬¾åˆ° Portfolio
     * @param asset èµ„äº§åœ°å€
     * @param amount é‡‘é¢
     * @param portfolioId Portfolio ID
     */
    function repayToPortfolio(
        address asset,
        uint256 amount,
        uint256 portfolioId
    ) external {
        require(amount > 0, "Amount must be > 0");

        IERC20(asset).safeTransferFrom(msg.sender, address(this), amount);
        IERC20(asset).safeApprove(address(pool), amount);

        pool.repay(asset, amount, uint256(2), address(this));

        emit Repaid(msg.sender, asset, amount, portfolioId);
    }

    /**
     * @dev è·å–ç”¨æˆ·è´¦æˆ·æ•°æ®
     */
    function getUserAccountData(address user)
        external
        view
        returns (
            uint256 totalCollateralBase,
            uint256 totalDebtBase,
            uint256 currentLiquidationThreshold,
            uint256 ltvs,
            uint256 healthFactor
        )
    {
        uint256[] memory interestRateModes = new uint256[](2);
        interestRateModes[0] = 1; // Stable
        interestRateModes[1] = 2; // Variable

        return pool.getUserAccountData(user, interestRateModes);
    }

    /**
     * @dev è®¡ç®—å¥åº·å› å­
     */
    function calculateHealthFactor(address user)
        external
        view
        returns (uint256 healthFactor)
    {
        (, , , , , healthFactor) = getUserAccountData(user);
    }

    /**
     * @dev æ£€æŸ¥æ˜¯å¦éœ€è¦æ¸…ç®—
     */
    function needLiquidation(address user) external view returns (bool) {
        uint256 healthFactor = calculateHealthFactor(user);
        return healthFactor < 1e18; // 1.00 = 100%
    }

    // ========== ç®¡ç†å‡½æ•° ==========

    function withdraw(address token, uint256 amount) external onlyOwner {
        IERC20(token).safeTransfer(owner, amount);
    }

    receive() external payable {}
}
```

### 33.3 Compound V3

**æ ¸å¿ƒåˆ›æ–°ï¼š**

```
Compound V3 æ–°ç‰¹æ€§ï¼š

1. cTokenï¼ˆCometï¼‰å‡çº§
   - æ›´é«˜æ•ˆçš„è´¦æˆ·æŠ½è±¡
   - åŸç”Ÿæ”¯æŒå¤šèµ„äº§æŠµæŠ¼
   - æ”¹è¿›çš„ Gas ä¼˜åŒ–

2. Cometsï¼ˆå¤šèµ„äº§æ± ï¼‰
   - æ”¯æŒå¤šç§æŠµæŠ¼å“
   - åŠ¨æ€è°ƒæ•´å‚æ•°
   - ç‹¬ç¼–ç åˆ©ç‡æ›²çº¿

3. Supply & Borrow Caps
   - é™åˆ¶æ€»ä¾›åº”é‡
   - é˜²æ­¢å¤§é¢å†²å‡»
   - é£é™©ç®¡ç†

4. Collateral Factorï¼ˆæŠµæŠ¼å› å­ï¼‰ä¼˜åŒ–
   - é’ˆå¯¹ä¸åŒèµ„äº§çš„ä¸åŒå› å­
   - åŠ¨æ€è°ƒæ•´
```

### 33.4 MakerDAOï¼ˆDSR - DAI Savings Rateï¼‰

**DSRï¼ˆDAI Savings Rateï¼‰ï¼š**

```
MakerDAO çš„ DAI Savings Rate å…è®¸ DAI æŒæœ‰è€…è·å¾—æ”¶ç›Šã€‚

å·¥ä½œåŸç†ï¼š
1. ç”¨æˆ·å°† DAI å­˜å…¥ DSR åˆçº¦
2. è·å¾— sDAIï¼ˆSaving DAIï¼‰
3. sDAI å¯éšæ—¶èµå›ä¸º DAI + ç´¯ç§¯åˆ©æ¯
4. åˆ©ç‡ç”± MakerDAO æ²»ç†æŠ•ç¥¨å†³å®š

ç‰¹ç‚¹ï¼š
- æ— éœ€ä¿¡ä»»
- æ²¡æœ‰é”å®šæ—¶é—´
- åˆ©ç‡è‡ªåŠ¨ç´¯ç§¯
- å¯ä»¥ç”¨äºå…¶ä»– DeFiï¼ˆéƒ¨åˆ†æ”¯æŒï¼‰
```

**DSR é›†æˆç¤ºä¾‹ï¼š**

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

/**
 * @title MakerDAO DSR é›†æˆ
 * @author ä¸Šç­‰å…µâ€¢ç”˜
 */
contract MakerDsrIntegration {
    using SafeERC20 for IERC20;

    // ========== æ¥å£ ==========
    interface IDaiPot {
        function join(uint256 wad) external;
        function exit(uint256 wad) external;
        function drip() external;
        function chi() external view returns (uint256);
    }

    interface IERC20 {
        function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
        function approve(address spender, uint256 amount) external returns (bool);
    }

    // ========== å¸¸é‡ ==========
    address public constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
    address public constant DAI_POT = 0x197E90f9FAD81970bA7976f33CbE71Aeb6083a;

    // ========== çŠ¶æ€å˜é‡ ==========
    address public owner;
    mapping(address => uint256) public userDaiDeposit;
    mapping(address => uint256) public userSDaiBalance;
    mapping(address => uint256) public lastChi;
    mapping(address => uint256) public lastTime;

    // ========== äº‹ä»¶ ==========
    event Deposited(address indexed user, uint256 amount, uint256 sDaiMinted);
    event Withdrew(address indexed user, uint256 sDaiAmount, uint256 daiReceived);
    event InterestClaimed(address indexed user, uint256 interest);

    // ========== ä¿®é¥°ç¬¦ ==========
    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner");
        _;
    }

    // ========== æ„é€ å‡½æ•° ==========
    constructor() {
        owner = msg.sender;
    }

    // ========== æ ¸å¿ƒåŠŸèƒ½ ==========

    /**
     * @dev å­˜å…¥ DAI åˆ° DSR
     * @param amount DAI æ•°é‡
     */
    function depositDsr(uint256 amount) external {
        require(amount > 0, "Amount must be > 0");

        // è½¬å…¥ DAI
        IERC20(DAI).transferFrom(msg.sender, DAI_POT, amount);

        // å­˜å…¥ DSR
        IDaiPot(DAI_POT).join(amount);

        // è®°å½•ç”¨æˆ·çŠ¶æ€
        uint256 chi = IDaiPot(DAI_POT).chi();
        uint256 sDaiAmount = (amount * chi) / 1e27;

        userDaiDeposit[msg.sender] += amount;
        userSDaiBalance[msg.sender] += sDaiAmount;
        lastChi[msg.sender] = chi;
        lastTime[msg.sender] = block.timestamp;

        emit Deposited(msg.sender, amount, sDaiAmount);
    }

    /**
     * @dev ä» DSR æå– DAI
     * @param sDaiAmount sDAI æ•°é‡
     */
    function withdrawDsr(uint256 sDaiAmount) external {
        require(sDaiAmount > 0, "Amount must be > 0");
        require(userSDaiBalance[msg.sender] >= sDaiAmount, "Insufficient sDAI balance");

        // è°ƒç”¨ drip æ›´æ–° chi
        IDaiPot(DAI_POT).drip();

        // æå–
        IDaiPot(DAI_POT).exit(sDaiAmount);

        uint256 chi = IDaiPot(DAI_POT).chi();
        uint256 daiAmount = (sDaiAmount * 1e27) / chi;

        // æ›´æ–°çŠ¶æ€
        userSDaiBalance[msg.sender] -= sDaiAmount;
        userDaiDeposit[msg.sender] -= daiAmount;

        uint256 interest = daiAmount - (sDaiAmount * lastChi[msg.sender]) / 1e27;

        emit Withdrew(msg.sender, sDaiAmount, daiAmount);
        emit InterestClaimed(msg.sender, interest);
    }

    /**
     * @dev è®¡ç®—ç´¯ç§¯åˆ©æ¯
     */
    function calculateInterest(address user)
        external
        view
        returns (uint256 interest)
    {
        if (userDaiDeposit[user] == 0) {
            return 0;
        }

        // è°ƒç”¨ drip æ›´æ–° chiï¼ˆä»…è§†å›¾ï¼‰
        uint256 currentChi = IDaiPot(DAI_POT).chi();
        uint256 sDaiValueAtDeposit = (userDaiDeposit[user] * lastChi[user]) / 1e27;

        uint256 currentValue = (userSDaiBalance[user] * currentChi) / 1e27;

        interest = currentValue - userDaiDeposit[user];
    }

    /**
     * @dev è·å–ç”¨æˆ· DSR ä¿¡æ¯
     */
    function getUserDsrInfo(address user)
        external
        view
        returns (
            uint256 daiDeposit,
            uint256 sDaiBalance,
            uint256 currentChi,
            uint256 depositChi,
            uint256 totalInterest
        )
    {
        daiDeposit = userDaiDeposit[user];
        sDaiBalance = userSDaiBalance[user];
        currentChi = IDaiPot(DAI_POT).chi();
        depositChi = lastChi[user];

        if (daiDeposit > 0) {
            uint256 currentValue = (sDaiBalance * currentChi) / 1e27;
            totalInterest = currentValue - daiDeposit;
        }
    }

    /**
     * @dev æ‰¹é‡å­˜å…¥
     */
    function batchDeposit(uint256[] calldata amounts) external {
        for (uint256 i = 0; i < amounts.length; ) {
            if (amounts[i] > 0) {
                IERC20(DAI).transferFrom(
                    msg.sender,
                    DAI_POT,
                    amounts[i]
                );
            }
            unchecked { ++i; }
        }

        // æ‰¹é‡å­˜å…¥
        for (uint256 i = 0; i < amounts.length; ) {
            if (amounts[i] > 0) {
                IDaiPot(DAI_POT).join(amounts[i]);

                uint256 chi = IDaiPot(DAI_POT).chi();
                uint256 sDaiAmount = (amounts[i] * chi) / 1e27;

                userDaiDeposit[msg.sender] += amounts[i];
                userSDaiBalance[msg.sender] += sDaiAmount;
                lastChi[msg.sender] = chi;
                lastTime[msg.sender] = block.timestamp;

                emit Deposited(msg.sender, amounts[i], sDaiAmount);
            }
            unchecked { ++i; }
        }
    }

    // ========== ç®¡ç†å‡½æ•° ==========

    function withdraw(address token, uint256 amount) external onlyOwner {
        IERC20(token).safeTransfer(owner, amount);
    }
}
```

---

## ä¸‰åå››ã€Lending åè®®å¯¹æ¯”

| ç‰¹æ€§ | Aave V3 | Compound V3 | MakerDAO |
|------|-----------|-------------|----------|
| **TVL** | $10B+ | $3B+ | $5B+ |
| **æŠµæŠ¼ç‡** | 110-150% | 110-150% | 110-170% |
| **åˆ©ç‡æ¨¡å‹** | ç®—æ³•ï¼ˆç¨³å®š/å¯å˜ï¼‰ | ç®—æ³• | æ²»ç†æŠ•ç¥¨ |
| **å¤šèµ„äº§æŠµæŠ¼** | âœ… æ”¯æŒ | âœ… æ”¯æŒ | âŒ ä¸æ”¯æŒ |
| **Portfolios** | âœ… æœ€å¤š 20 ä¸ª | âŒ | âŒ |
| **æ•ˆç‡æ¨¡å¼** | âœ… æ”¯æŒ | âŒ | âŒ |
| **éš”ç¦»æ¨¡å¼** | âœ… æ”¯æŒ | âŒ | âŒ |
| **ä¸»è¦åˆ›æ–°** | Portfolios, æ•ˆç‡æ¨¡å¼ | cToken å‡çº§ | DSR æ”¶ç›Š |

---

## ä¸‰åäº”ã€Flash Loans åœ¨ Lending ä¸­çš„åº”ç”¨

### 35.1 é—ªç”µè´·æ¸…ç®—

**æ¸…ç®—æµç¨‹ï¼š**

```
1. ç›‘æ§å¥åº·å› å­
   - æ£€æµ‹å¥åº·å› å­ < 1 çš„è´¦æˆ·
   - å¯é€šè¿‡äº‹ä»¶æˆ–é“¾ä¸‹ç›‘æ§

2. è®¡ç®—æ¸…ç®—åˆ©æ¶¦
   - æ¸…ç®—å¥–åŠ±
   - æŠµæŠ¼å“ä»·æ ¼
   - å€ºåŠ¡ä»·å€¼

3. ä½¿ç”¨é—ªç”µè´·
   - å€Ÿå…¥ USDC
   - æ¸…ç®—å€ºåŠ¡
   - è·å¾—æŠµæŠ¼å“ï¼ˆæŠ˜æ‰£ä»·ï¼‰
   - åœ¨ DEX å–å‡ºæŠµæŠ¼å“
   - å¿è¿˜é—ªç”µè´· + è·åˆ©

4. ç›ˆåˆ©æ¡ä»¶ï¼š
   æ¸…ç®—æŠ˜æ‰£ + æŠµæŠ¼å“å‡å€¼ > æ‰‹ç»­è´¹ + Gas
```

**é—ªç”µè´·æ¸…ç®—åˆçº¦ï¼š**

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title é—ªç”µè´·æ¸…ç®—æœºå™¨äºº
 * @author ä¸Šç­‰å…µâ€¢ç”˜
 */
contract FlashLoanLiquidationBot {
    using SafeERC20 for IERC20;

    // ========== æ¥å£ ==========
    interface IPool {
        function flashLoan(
            address receiverAddress,
            address[] calldata assets,
            uint256[] calldata amounts,
            uint256[] calldata interestRateModes,
            address onBehalfOf,
            bytes calldata params,
            uint16 referralCode
        ) external;
    }

    interface IAaveV3Pool {
        struct LiquidationCallParams {
            address collateralAsset;
            address debtAsset;
            address user;
            uint256 debtToCover;
            bool receiveAToken;
        }

        function liquidationCall(LiquidationCallParams calldata params) external;
    }

    interface IUniswapV2Router {
        function getAmountsOut(
            uint256 amountIn,
            address[] calldata path
        ) external view returns (uint256[] memory amounts);

        function swapExactTokensForTokens(
            uint256 amountIn,
            uint256 amountOutMin,
            address[] calldata path,
            address to,
            uint256 deadline
        ) external returns (uint256[] memory amounts);
    }

    // ========== å¸¸é‡ ==========
    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address public constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address public constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
    address public constant UNISWAP_V2_ROUTER =
        0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;

    IPool public immutable pool;
    IAaveV3Pool public immutable aavePool;
    address public immutable owner;

    // ========== çŠ¶æ€å˜é‡ ==========
    uint256 public totalLiquidated;
    uint256 public totalProfit;

    // ========== äº‹ä»¶ ==========
    event LiquidationExecuted(
        address indexed user,
        address indexed collateralAsset,
        uint256 debtCovered,
        uint256 collateralReceived,
        uint256 profit
    );

    // ========== ä¿®é¥°ç¬¦ ==========
    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner");
        _;
    }

    // ========== æ„é€ å‡½æ•° ==========
    constructor(
        address _poolAddressProvider,
        address _aavePool
    ) {
        IPoolAddressesProvider provider = IPoolAddressesProvider(_poolAddressProvider);
        pool = IPool(provider.getPool());
        aavePool = IAaveV3Pool(_aavePool);
        owner = msg.sender;
    }

    // ========== æ ¸å¿ƒåŠŸèƒ½ ==========

    /**
     * @dev æ‰§è¡Œé—ªç”µè´·æ¸…ç®—
     * @param user è¦æ¸…ç®—çš„ç”¨æˆ·
     * @param debtAsset å€ºåŠ¡èµ„äº§
     * @param collateralAsset æŠµæŠ¼å“èµ„äº§
     * @param debtToCover è¦æ¸…ç®—çš„å€ºåŠ¡é‡‘é¢
     * @param swapPath Uniswap è·¯å¾„ï¼ˆå¦‚æœéœ€è¦ï¼‰
     */
    function executeFlashLiquidation(
        address user,
        address debtAsset,
        address collateralAsset,
        uint256 debtToCover,
        address[] calldata swapPath
    ) external {
        // 1. å€Ÿå…¥ USDC é€šè¿‡é—ªç”µè´·
        bytes memory params = abi.encode(
            user,
            debtAsset,
            collateralAsset,
            debtToCover,
            swapPath
        );

        address[] memory assets = new address[](1);
        assets[0] = USDC;

        uint256[] memory amounts = new uint256[](1);
        amounts[0] = debtToCover;

        uint256[] memory modes = new uint256[](1);
        modes[0] = 0;

        pool.flashLoan(
            address(this),
            assets,
            amounts,
            modes,
            address(this),
            params,
            0
        );
    }

    /**
     * @dev é—ªç”µè´·å›è°ƒ
     */
    function executeOperation(
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata premiums,
        address initiator,
        bytes calldata params
    ) external returns (bool) {
        require(msg.sender == address(pool), "Invalid caller");
        require(initiator == owner, "Invalid initiator");

        uint256 flashLoanAmount = amounts[0];
        uint256 premium = premiums[0];
        uint256 totalRepay = flashLoanAmount + premium;

        // è§£ç å‚æ•°
        (
            address user,
            address debtAsset,
            address collateralAsset,
            uint256 debtToCover,
            address[] memory swapPath
        ) = abi.decode(params, (
                address,
                address,
                address,
                uint256,
                address[]
            ));

        // 2. æ‰¹å‡†å¹¶æ¸…ç®—
        IERC20(debtAsset).safeApprove(address(aavePool), debtToCover);

        IAaveV3Pool.LiquidationCallParams memory liquidationParams =
            IAaveV3Pool.LiquidationCallParams({
                collateralAsset: collateralAsset,
                debtAsset: debtAsset,
                user: user,
                debtToCover: debtToCover,
                receiveAToken: false
            });

        aavePool.liquidationCall(liquidationParams);

        // 3. è·å¾—æŠµæŠ¼å“
        uint256 collateralBalance = IERC20(collateralAsset).balanceOf(address(this));

        // 4. å¦‚æœéœ€è¦ï¼Œåœ¨ Uniswap å–å‡º
        uint256 finalAmount = collateralBalance;
        if (swapPath.length > 0) {
            IERC20(collateralAsset).safeApprove(UNISWAP_V2_ROUTER, collateralBalance);

            uint256[] memory amountsOut = IUniswapV2Router(UNISWAP_V2_ROUTER)
                .swapExactTokensForTokens(
                    collateralBalance,
                    0,
                    swapPath,
                    address(this),
                    block.timestamp
                );

            finalAmount = amountsOut[amountsOut.length - 1]; // USDC
        }

        // 5. æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿèµ„é‡‘å¿è¿˜
        require(finalAmount >= totalRepay, "Insufficient profit");

        uint256 profit = finalAmount - totalRepay;

        // æ›´æ–°ç»Ÿè®¡
        totalLiquidated += debtToCover;
        totalProfit += profit;

        emit LiquidationExecuted(
            user,
            collateralAsset,
            debtToCover,
            collateralBalance,
            profit
        );

        // 6. æ‰¹å‡†å¹¶å¿è¿˜
        IERC20(USDC).safeApprove(address(pool), totalRepay);

        return keccak256("IERC3156FlashBorrower.onFlashLoan") ==
            keccak256("IERC3156FlashBorrower.onFlashLoan");
    }

    // ========== è¾…åŠ©åŠŸèƒ½ ==========

    /**
     * @dev è®¡ç®—æ¸…ç®—åˆ©æ¶¦
     */
    function calculateLiquidationProfit(
        uint256 debtAmount,
        uint256 collateralAmount,
        uint256 debtPrice,
        uint256 collateralPrice,
        uint256 liquidationBonus
    ) external pure returns (int256 profit) {
        // æ¸…ç®—è·å¾—æŠµæŠ¼å“ä»·å€¼
        uint256 collateralValue = (collateralAmount * collateralPrice) / 1e18;

        // æŠµæŠ¼å“ä»·å€¼ Ã— æ¸…ç®—å¥–åŠ±
        uint256 bonusValue = (collateralValue * liquidationBonus) / 10000; // liquidationBonus æ˜¯ bps

        // æ€»è·å¾—ä»·å€¼
        uint256 totalReceived = collateralValue + bonusValue;

        // æˆæœ¬ï¼ˆå€ºåŠ¡ä»·å€¼ï¼‰
        uint256 cost = (debtAmount * debtPrice) / 1e18;

        // åˆ©æ¶¦
        profit = int256(totalReceived) - int256(cost);
    }

    /**
     * @dev è·å–æ¸…ç®—ç»Ÿè®¡
     */
    function getStats()
        external
        view
        returns (
            uint256 totalLiquidated,
            uint256 totalProfit,
            uint256 profitRate
        )
    {
        totalLiquidated = this.totalLiquidated;
        totalProfit = this.totalProfit;

        if (totalLiquidated > 0) {
            profitRate = (totalProfit * 1e18) / totalLiquidated;
        }
    }

    // ========== ç®¡ç†å‡½æ•° ==========

    function withdraw(address token, uint256 amount) external onlyOwner {
        IERC20(token).safeTransfer(owner, amount);
    }
}
```

---

## ç¬¬åå°æ—¶å­¦åˆ°çš„æŠ€èƒ½æ€»ç»“

### 36.1 æ ¸å¿ƒæŠ€èƒ½

1. **DeFi Lending åè®®**
   - Over-collateralized Lending
   - Aave V3 Portfolios
   - Compound V3 cTokens
   - MakerDAO DSR

2. **Lending é›†æˆ**
   - Aave V3 Supply/Borrow
   - MakerDAO DSR
   - è´¦æˆ·ç®¡ç†
   - å¥åº·å› å­ç›‘æ§

3. **Flash Loans æ¸…ç®—**
   - é—ªç”µè´·æ¸…ç®—æœºåˆ¶
   - æ¸…ç®—åˆ©æ¶¦è®¡ç®—
   - é£é™©ç®¡ç†

4. **DeFi å·¥å…·**
   - èµ„é‡‘æ•ˆç‡ä¼˜åŒ–
   - å¤šèµ„äº§æŠµæŠ¼
   - éš”ç¦»æ¨¡å¼

### 36.2 ä»£ç äº§å‡º

- âœ… AaveV3PortfoliosIntegration Aave V3 æŠ•èµ„ç»„åˆ
- âœ… MakerDsrIntegration DSR é›†æˆ
- âœ… FlashLoanLiquidationBot é—ªç”µè´·æ¸…ç®—æœºå™¨äºº

---

**ã€ç¬¬10å°æ—¶æ±‡æŠ¥å®Œæ¯•ã€‘**
